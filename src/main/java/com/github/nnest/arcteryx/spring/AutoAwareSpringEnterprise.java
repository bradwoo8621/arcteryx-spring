/**
 * 
 */
package com.github.nnest.arcteryx.spring;

import java.lang.annotation.Annotation;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.BeanFactoryUtils;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ApplicationObjectSupport;

import com.github.nnest.arcteryx.IApplication;
import com.github.nnest.arcteryx.IComponent;
import com.github.nnest.arcteryx.IContainer;
import com.github.nnest.arcteryx.IEnterprise;
import com.github.nnest.arcteryx.ILayer;
import com.github.nnest.arcteryx.IResource;
import com.github.nnest.arcteryx.ResourceUtils;
import com.github.nnest.arcteryx.spring.stereotype.StereoTypeDetective;

/**
 * Enterprise spring aware.</br>
 * Any type of {@linkplain ApplicationContext} is accepted.</br>
 * </br>
 * <b>SpringEnterpriseAware</b>: Only one {@linkplain AutoAwareSpringEnterprise}
 * is allowed in application context. In hierarchy application contexts, it must
 * be defined in lowest level at least. Aware in high level will be skipped by
 * spring if low level existed. Note keep id of
 * {@linkplain AutoAwareSpringEnterprise} not defined, use spring default name
 * generator.</br>
 * Default {@linkplain AutoAwareSpringEnterprise} XML in
 * <b>META-INF/nnest/default-aware-spring.xml</b></br>
 * </br>
 * <b>Enterprise</b>: Only one {@linkplain IEnterprise} is allowed in
 * application context. In hierarchy application contexts,
 * {@linkplain IEnterprise} can be defined in any level, otherwise low level
 * will override the high level. Note keep id of {@linkplain IEnterprise} not
 * defined, use spring default name generator.</br>
 * Default {@linkplain IEnterprise} XML in
 * <b>META-INF/nnest/default-enterprise-spring.xml</b></br>
 * </br>
 * <b>Resourse</b>:</br>
 * {@linkplain IApplication} with no container will be added into enterprise
 * automatically.</br>
 * In normal application context (with no spring hierarchy application context),
 * bean id is not necessary. but container of resource is required.
 * {@linkplain AutoAwareSpringEnterprise} use container configuration to build
 * the application/component[/component]/resource tree.</br>
 * In hierarchy application context:</br>
 * 1. Not lowest level, each resource must have its bean id explicit to prevent
 * the duplicated auto generated bean id is same as other bean in lower
 * level.</br>
 * 2. Lowest level, bean id is not necessary.</br>
 * For resource type: 1. {@linkplain IApplication} with container must have same
 * resource id with its contianer's.</br>
 * 2. {@linkplain IComponent}, if want to replace the existed component in
 * higher level, define it use same resource id.</br>
 * 3. {@linkplain IResource}, if want to replace the existed resource in high
 * level, define it use same resource id.</br>
 * </br>
 * <font color='red'>Recommended: Define a prefix or suffix for bean id of each
 * level. {@linkplain AutoAwareSpringEnterprise} use resource id to build
 * hierarchy tree, not spring bean id, so always keep spring bean id
 * unique.</font></br>
 * </br>
 * An incorrect example:. </br>
 * parent: context-parent.xml</br>
 * 
 * <pre>
 * &lt;bean id="App1" class="com.github.nnest.arcteryx.Application"&gt;
 *		&lt;constructor-arg type="java.lang.String" value="App1" /&gt;
 * &lt;/bean&gt;
 * &lt;bean class="com.github.nnest.arcteryx.Component" p:container-ref="App1"&gt;
 *		&lt;constructor-arg type="java.lang.String" value="Comp11" /&gt;
 * &lt;/bean&gt;
 * </pre>
 * 
 * child: context-child.xml</br>
 * 
 * <pre>
 * &lt;bean class="com.github.nnest.arcteryx.Component" p:container-ref="App1"&gt;
 *		&lt;constructor-arg type="java.lang.String" value="Comp12" /&gt;
 * &lt;/bean&gt;
 * </pre>
 * 
 * ids of components in parent and child are both auto generated by spring as
 * <code>com.github.nnest.arcteryx.Component#0</code>, then component in parent
 * is overridden by child, cannot be aware. </br>
 * 
 * @author brad.wu
 */
public class AutoAwareSpringEnterprise extends ApplicationObjectSupport implements InitializingBean {
	private Map<Class<? extends Annotation>, IResourceDefinitionResolver> resourceDefinitionResolvers = null;

	/**
	 * get regardful annotations
	 * 
	 * @return the regardfulAnnotations
	 */
	public Map<Class<? extends Annotation>, IResourceDefinitionResolver> getResourceDefinitionResolvers() {
		return resourceDefinitionResolvers;
	}

	/**
	 * get resource definition resolver
	 * 
	 * @param annotationClass
	 * @return
	 */
	public IResourceDefinitionResolver getResourceDefinditionResolver(Class<? extends Annotation> annotationClass) {
		return this.resourceDefinitionResolvers.get(annotationClass);
	}

	/**
	 * set regardful annotations
	 * 
	 * @param regardfulAnnotations
	 *            the regardfulAnnotations to set
	 */
	public void setResourceDefinitionResolvers(
			Map<Class<? extends Annotation>, IResourceDefinitionResolver> regardfulAnnotations) {
		this.resourceDefinitionResolvers = regardfulAnnotations;
	}

	/**
	 * get enterprise
	 * 
	 * @return
	 */
	public IEnterprise getEnterprise() {
		return this.getApplicationContext().getBean(IEnterprise.class);
	}

	/**
	 * (non-Javadoc)
	 * 
	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	public void afterPropertiesSet() throws Exception {
		IEnterprise enterprise = this.getEnterprise();
		this.setupApplications(this.getApplicationContext(), enterprise);
		enterprise.startup();
	}

	/**
	 * setup applications
	 * 
	 * @param applicationContext
	 * @param enterprise
	 */
	protected void setupApplications(ApplicationContext applicationContext, IEnterprise enterprise) {
		Map<String, IResource> resources = BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext,
				IResource.class);
		for (Map.Entry<String, IResource> entry : resources.entrySet()) {
			String beanName = entry.getKey();
			IResource resource = entry.getValue();
			IContainer container = resource.getContainer();
			if (container == null) {
				container = findContainer(applicationContext, beanName, resource);
				if (container != null) {
					ResourceUtils.registerResource(container, resource);
				} else {
					// still not found container
					this.setupResourceTopLevel(enterprise, resource);
				}
			} else {
				container.registerResource(resource);
			}
		}

		// process the beans which doesn't implement the interface
		Map<Class<? extends Annotation>, IResourceDefinitionResolver> regardfulAnnotations = this
				.getResourceDefinitionResolvers();
		if (regardfulAnnotations != null && regardfulAnnotations.size() != 0) {
			Map<String, IAnnotatedResource> resourceMap = new HashMap<String, IAnnotatedResource>();
			for (Class<? extends Annotation> annotationClass : regardfulAnnotations.keySet()) {
				resourceMap.putAll(this.scanBeansByAnnotation(applicationContext, annotationClass, enterprise));
			}
			for (Map.Entry<String, IAnnotatedResource> entry : resourceMap.entrySet()) {
				IAnnotatedResource resource = entry.getValue();
				this.findContainerAndRegister(applicationContext, enterprise, resourceMap, resource);
			}
		} else {
			this.getLogger().info("No regardful annotations");
		}
	}

	/**
	 * find container in applicationContext or resource map.</br>
	 * if resource is an application and no parent application appointed,
	 * register into enterprise; otherwise register into its container
	 * 
	 * @param applicationContext
	 * @param enterprise
	 * @param resourceMap
	 * @param resource
	 */
	protected void findContainerAndRegister(ApplicationContext applicationContext, IEnterprise enterprise,
			Map<String, IAnnotatedResource> resourceMap, IAnnotatedResource resource) {
		String containerId = resource.getContainerBeanId();
		ILayer layer = resource.getLayer();
		if (resource instanceof IApplication) {
			if (StringUtils.isEmpty(layer.getParentId())) {
				// no parent layer found, register as top level
				// application
				this.setupResourceTopLevel(enterprise, resource);
			} else {
				// find parent application
				String parentApplicationBeanId = StereoTypeDetective.buildResourceBeanId(layer.getParentId(),
						containerId);
				this.findContainerAndRegister(applicationContext, resourceMap, resource, parentApplicationBeanId);
			}
		} else {
			String parentContainerBeanId = StereoTypeDetective.buildResourceBeanId(layer.getId(), containerId);
			this.findContainerAndRegister(applicationContext, resourceMap, resource, parentContainerBeanId);
		}
	}

	/**
	 * find container in application context or resource map. and register into
	 * its container.
	 * 
	 * @param applicationContext
	 * @param resourceMap
	 * @param resource
	 * @param parentContainerBeanId
	 */
	protected void findContainerAndRegister(ApplicationContext applicationContext,
			Map<String, IAnnotatedResource> resourceMap, IAnnotatedResource resource, String parentContainerBeanId) {
		if (applicationContext.containsBean(parentContainerBeanId)) {
			ResourceUtils.registerResource((IContainer) applicationContext.getBean(parentContainerBeanId), resource);
		} else {
			ResourceUtils.registerResource((IContainer) resourceMap.get(parentContainerBeanId), resource);
		}
	}

	/**
	 * scan beans by annotation
	 * 
	 * @param applicationContext
	 * @param annotationClass
	 * @param enterprise
	 */
	protected Map<String, IAnnotatedResource> scanBeansByAnnotation(ApplicationContext applicationContext,
			Class<? extends Annotation> annotationClass, IEnterprise enterprise) {
		if (applicationContext instanceof ConfigurableApplicationContext) {
			String[] beanIds = applicationContext.getBeanNamesForAnnotation(annotationClass);
			if (beanIds == null || beanIds.length == 0) {
				// do nothing
				return Collections.emptyMap();
			}

			Map<String, IAnnotatedResource> resourceMap = new HashMap<String, IAnnotatedResource>();
			ConfigurableApplicationContext configurableContext = (ConfigurableApplicationContext) applicationContext;
			ConfigurableListableBeanFactory beanFactory = configurableContext.getBeanFactory();
			for (String beanId : beanIds) {
				BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanId);
				if (isResourceInterfaceImplemented(beanDefinition)) {
					// already scanned by interface
					continue;
				}
				IAnnotatedResource[] resources = this.createResource(configurableContext, beanDefinition, beanId,
						annotationClass);
				if (resources != null) {
					for (IAnnotatedResource resource : resources) {
						ILayer layer = resource.getLayer();
						String id = resource.getId();
						resourceMap.put(StereoTypeDetective.buildResourceBeanId(layer.getId(), id), resource);
					}
				}
			}
			return resourceMap;
		} else {
			return this.scanBeansByAnnotationInUnconfigurableContext(applicationContext, annotationClass, enterprise);
		}
	}

	/**
	 * is resource interface implemented
	 * 
	 * @param beanDefinition
	 * @return
	 */
	protected boolean isResourceInterfaceImplemented(BeanDefinition beanDefinition) {
		try {
			return IResource.class.isAssignableFrom(Class.forName(beanDefinition.getBeanClassName()));
		} catch (ClassNotFoundException e) {
			throw new IllegalResourceDefinitionException(e);
		}
	}

	/**
	 * create resource by given application context and bean definition
	 * 
	 * @param configurableContext
	 * @param beanDefinition
	 * @param beanId
	 * @param annotationClass
	 * @return
	 */
	protected IAnnotatedResource[] createResource(ConfigurableApplicationContext configurableContext,
			BeanDefinition beanDefinition, String beanId, Class<? extends Annotation> annotationClass) {
		IResourceDefinitionResolver resolver = this.getResourceDefinditionResolver(annotationClass);
		return resolver.createResource(configurableContext, beanDefinition, beanId, annotationClass);
	}

	/**
	 * scan beans by annotation in unconfigurable context.</br>
	 * default do nothing since {@linkplain ApplicationContext} always be an
	 * instance of {@linkplain ConfigurableApplicationContext}.
	 * 
	 * @param applicationContext
	 * @param annotationClass
	 * @param enterprise
	 */
	protected Map<String, IAnnotatedResource> scanBeansByAnnotationInUnconfigurableContext(
			ApplicationContext applicationContext, Class<? extends Annotation> annotationClass,
			IEnterprise enterprise) {
		this.getLogger().error("Ignore finding bean of annotation [{}] cause by application context is not a ",
				annotationClass, ConfigurableApplicationContext.class);
		return Collections.emptyMap();
	}

	/**
	 * find container in application context
	 * 
	 * @param applicationContext
	 * @param beanName
	 * @param resource
	 * @return
	 */
	protected IContainer findContainer(ApplicationContext applicationContext, String beanName, IResource resource) {
		// only when application context is ConfigurableApplicationContext,
		// get bean definition to determine the container
		if (applicationContext instanceof ConfigurableApplicationContext) {
			return this.findContainer((ConfigurableApplicationContext) applicationContext, beanName, resource);
		} else {
			this.getLogger().error("Skip find container of [{}] cause by application context is not a {}", beanName,
					ConfigurableApplicationContext.class);
		}
		return null;
	}

	/**
	 * find container in configurable application context
	 * 
	 * @param applicationContext
	 * @param beanName
	 * @param resource
	 * @return
	 */
	protected IContainer findContainer(ConfigurableApplicationContext applicationContext, String beanName,
			IResource resource) {
		// case to configurable application context and get bean factory
		ConfigurableApplicationContext configurableContext = (ConfigurableApplicationContext) applicationContext;
		ConfigurableListableBeanFactory beanFactory = configurableContext.getBeanFactory();

		// find the bean definition by bean name
		if (beanFactory.containsBeanDefinition(beanName)) {
			BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);
			if (beanDefinition instanceof AnnotatedBeanDefinition) {
				AnnotatedBeanDefinition annotatedDefinition = (AnnotatedBeanDefinition) beanDefinition;
				String containerBeanId = null;
				if (resource instanceof IApplication) {
					// for IApplication
					containerBeanId = StereoTypeDetective.determineParentApplicationBeanId(annotatedDefinition);
					// even parent application bean id was determined
					// the application bean not contains in application
					// context
					// still treat it as correct case
					// the application will be registered into enterprise as
					// top level application
					if (!StringUtils.isEmpty(containerBeanId) && configurableContext.containsBean(containerBeanId)) {
						return applicationContext.getBean(containerBeanId, IContainer.class);
					}
				} else {
					// for other kind of resource
					containerBeanId = StereoTypeDetective.determineContainerBeanId(annotatedDefinition);
					if (!StringUtils.isEmpty(containerBeanId)) {
						return applicationContext.getBean(containerBeanId, IContainer.class);
					}
				}
			}
		} else {
			this.getLogger().error("Bean definition [{}] not found in application context", beanName);
		}
		return null;
	}

	/**
	 * setup resource in top level (no container found)
	 * 
	 * @param enterprise
	 * @param resource
	 */
	protected void setupResourceTopLevel(IEnterprise enterprise, IResource resource) {
		if (resource instanceof IApplication) {
			// only prepare the top level applications
			enterprise.prepareApplication((IApplication) resource);
		} else {
			throw new IllegalResourceDefinitionException(
					"Container not defined with resource " + resource.getClass() + "[" + resource.getId() + "]");
		}
	}

	/**
	 * get logger
	 * 
	 * @return
	 */
	protected Logger getLogger() {
		return LoggerFactory.getLogger(getClass());
	}
}
